# 前言
异常检测的场景很多，例如硬件的故障检测、流量的异常点的检测等场景。这篇博客我们针对的是时间序列的异常检测。时间序列异常的检测算法有很多，业界比较流行的比如普通的统计学习方法--3σ原则，它利用检测点偏移量来检测出异常。比如普通的回归方法，用曲线拟合方法来检测新的节点和拟合曲线的偏离程度，甚至有人讲CNN和RNN技术应用到异常点的检测。

通过普通的阈值来检测流量异常的方法效果比较差，本篇文章提出了一种新的检测算法，下面将重点介绍我们在实践过程中的经验。


# 异常检测算法

## 基于曲线拟合的检测方法

对于时间序列（是指将同一统计指标的数值按其发生的时间先后顺序排列而成的数列）来说，T时刻的数值对于T-1时刻有很强的依赖性。比如某个游乐园人数在8:00很多，在8:01时刻的人数很多的概率是很大的，但是如果07:01时刻人数对于8:01时刻影响不是很大。

针对最近时间窗口内的数据遵循某种趋势的现象，我们使用一条曲线对该趋势进行拟合，如果新的数据打破了这种趋势，使曲线变得不平滑，则该点就出现了异常。

曲线拟合的方法有很多，比如回归、moving  average……。在这篇文章中，我们使用EWMA，即指数权重移动平均方法来拟合曲线。EWMA的递推公式是：

```
EWMA(1) = p(1)  // 有时也会取前若干值的平均值。α越小时EWMA(1)的取值越重要。
EWMA(i) = α * p(i) + (1-α) * EWMA(i – 1) // α是一个0-1间的小数，称为smoothing factor.
```
可以从上面公式得出，下一点的平均值是由上一点的平均值，加上当前点的实际值修正而来。对于每一个EWMA值，每个数据的权重是不一样的，最近的数据将拥有越高的权重。

有了平均值之后，我们就可以使用3-sigma理论来判断新的input是否超过了容忍范围。比较实际的值是否超出了这个范围就可以知道是否可以告警了。超出了上界，可能是流量突然增加了；低于下界，可能是流量突然降低了，这两种情况都需要告警。我们可以使用pandas库中的ewma函数来实现我们上面的计算过程。

EWMA由于其时效性被广泛应用在时间序列的预测，它的优势在于:

- 可以检测到一个异常较短时间后发生的另一个(不太高的突变型)异常；
- 因为它更多的是参考突变之前的点，所以能更快对异常作出反应；
- 非常敏感，历史如果波动很小，方差就很小，容忍的波动范围也会非常小；

而劣势则是

- 对渐进型而非突发型的异常检测能力较弱；
- 异常持续一段时间后可能被判定为正常；
- 业务曲线可能自身有规律性的陡增和陡降；
- 过于敏感，容易误报。因为方差会随着异常点的引入而变大，所以很难使用连续三点才告警这样的策略；

所以我们需要引入周期性的检测方法，来针对性处理具有周期性趋势的曲线。

## 统计检测算法

### 基于同期数据的检测方法

很多监控项都具有一定的周期性，其中以一天为周期的情况比较常见，比如VIP流量在早上4点最低，而在晚上11点最高。为了将监控项的周期性考虑进去，我们选取了某个监控项过去14天的数据。对于某个时刻，将得到14个点可以作为参考值，我们记为xi，其中i=1,...,14。

我们先考虑静态阈值的方法来判断input是否异常（突增和突减）。如果input比过去14天同一时刻的最小值乘以一个阈值还小，就会认为该输入为异常点（突减）；而如果input
比过去14天同一时刻的最大值乘以一个阈值还大，就会认为该输入为异常点（突增）。

静态阈值的方法是根据历史经验得出的值，实际中如何给max_threshold和min_threshold是一个需要讨论的话题。根据目前动态阈值的经验规则来说，取平均值是一个比较好的思路。

上面我们把基于同期数据的检测方法进行了说明，下面我们讨论一下它的优缺点：

优点：
- 反映出周期性；
- 可以确保发现大的故障，出了告警一定是大问题；

缺点：
- 依赖周期性的历史数据，计算量大，而且无法对新接入的曲线告警；
- 非常不敏感，小波动无法发现；

### 基于同期振幅的检测方法

检测方法二遇到下图的现象就不能检测出异常。比如今天是11.18日，过去14天的历史曲线必然会比今天的曲线低很多。那么今天出了一个小故障，曲线下跌了，相对于过去14天的曲线仍然是高很多的。这样的故障使用方法二就检测不出来，那么我们将如何改进我们的方法呢？一个直觉的说法是，两个曲线虽然不一样高，但是“长得差不多”。那么怎么利用这种“长得差不多”呢？那就是振幅了。

![image](http://p0.qhimg.com/t0163efc1cf9a21e439.png)

怎么计算t时刻的振幅呢？ 我们使用x(t) – x(t-1) 再除以 x(t-1)来表示振幅。举个例子，例如t时刻的在线900人，t-1时刻的在线是1000人，那么可以计算出掉线人数是10%。如果参考过去14天的数据，我们会得到14个振幅值。使用14个振幅的绝对值作为标准，如果m时刻的振幅（{m(t) – m(t-1)]/m(t-1)）大于amplitude*threshold并且m时刻的振幅大于0，则我们认为该时刻发生突增，而如果m时刻的振幅大于amplitude*threshold并且m时刻的振幅小于0，则认为该时刻发生突减。

![image](http://p0.qhimg.com/t018cd29339b4a3d70e.png)

同样，我们也讨论一下该方法的优缺点，先说优点：

- 比绝对值要敏感；
- 利用了时间周期性，规避了业务曲线自身的周期性陡降；

缺点：

- 要求原曲线是光滑的；
- 周期性陡降的时间点必须重合，否则误警；
- 按百分比计算容易在低峰时期误警；
- 陡降不一定代表故障，由上层服务波动引起的冲高再回落的情况时有发生；

### 基于环比数据的检测算法

对于时间序列（是指将同一统计指标的数值按其发生的时间先后顺序排列而成的数列）来说，T时刻的数值对于T-1时刻有很强的依赖性。比如流量在8:00很多，在8:01时刻的概率是很大的，但是如果07:01时刻对于8:01时刻影响不是很大。

首先，我们可以使用最近时间窗口（T）内的数据遵循某种趋势的现象来做文章。比如我们将T设置为7，则我们取检测值（now_value）和过去7个（记为i）点进行比较，如果大于阈值我们将count加1，如果count超过我们设置的count_num，则认为该点是异常点。

![img](https://ws2.sinaimg.cn/large/006tNbRwly1fxfqrj1adgj30de02nq2s.jpg)

上面的公式涉及到threshold和count_num两个参数，threshold如何获取我们将在下节进行介绍，而count_num可以根据的需求进行设置，比如对异常敏感，可以设置count_num小一些，而如果对异常不敏感，可以将count_num设置的大一些。

业界关于动态阈值设置的方法有很多，今天介绍一种针对我们lvs流量异常检测的阈值设置方法。通常阈值设置方法会参考过去一段时间内的均值、最大值以及最小值，我们也同样应用此方法。取过去一段时间（比如T窗口）的平均值、最大值以及最小值，然后取max-avg和avg-min的最小值。之所以取最小值的原因是让筛选条件设置的宽松一些，让更多的值通过此条件，减少一些漏报的事件。

![img](https://ws2.sinaimg.cn/large/006tNbRwly1fxfqstwj3cj30a401hq2q.jpg)

## iForest

iForest算法是周志华老师于2010年设计的一种异常点检测算法，该方法利用数据构建iTree，进而构建iForest，是一种无监督的检测方法，具有很好的效果，具体算法可参见：http://www.cnblogs.com/fengfenggirl/p/iForest.html

这里我们给出该算法的简单介绍：

iForest是由iTree构建而成的，因此我们首先介绍iTree。iTree是一种随机二叉树，每个节点要么有两个子节点，要么该节点为叶子节点。对于给定的数据集D，数据集中的所有的特征都是连续变量，iTree的构造如下：

(1) 在数据集D中随机选择一个特征A；

(2) 随机选择特征A的一个可能取值value；

(3) 根据特征A以及值value将数据集D分为两个子集，将特征A的值小于value的样本归入左子节点，余下部分归入右子节点；

(4)递归构造左右子树直至满足以下的终止条件：

a. 传入的数据集只有一条记录或者多条相同记录

b. 树的高度达到了限定高度

iTree建立好了以后，就可以对数据进行预测了，预测的过程是将测试记录在iTree上面走一遍。iTree能有效的检测异常点是基于异常点都很稀有这一假设，异常点应该在iTree中很快被划分到叶子节点，因此可以利用检测点被分入的叶子节点到根的路径长度h(x)判断检测点x是否为异常点。

在构建好了iTree后就可以构建iForest，iForest中的每棵树在构造时并不是将所有的数据都用上，而是随机采样，抽取一部分构造iTree，尽量保证每棵树都不相同。事实上，如果iTree在构造时运用很多的数据点反而不能得到很好的效果，主要因为数据点会有重叠，因此效果不够显著。而且因为由iTree变成iForest因此S(x,n)的计算公式也要改变，将h(x)变为E(h(x))是检测点x在每棵树上的平均高度。iForest算法在python中有现成的包可以调用。

利用iForest算法进行判断时，如果检测点的孤立森林分数为正数，那么检测点为正常点，否则为异常点。

## 投票机制

上面介绍了五种方法，为了减少单个算法的误报情况，我们采用投票机制，如果多数算法认为该点为异常点，才最终认为是异常点。

![image-20181024175555523](https://ws3.sinaimg.cn/large/006tNbRwly1fwkn8n6eakj30fo0dgaas.jpg)

# 总结

上面介绍了五种检测的方法，每个方法都有每个方法的优缺点，也有每个方法能检测和不能检测的范围。因此单纯依靠一种方法并不能达到我们预期的效果，而且具有很高的误报率。我们借鉴了投票制度中“少数服从多数”的原则，即多数以上符合，我们才认为符合。

如果你觉得上面的五种方法还不够精确，你甚至可以使用开源项目skyline来丰富你的算法库，进一步提高准确率。